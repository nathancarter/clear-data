<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>clear_data.dataframe_extensions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clear_data.dataframe_extensions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import clear_data.series_extensions

def dataframe_is_a_function ( self, input, output ):
    &#34;&#34;&#34;
    Does the given DataFrame represent a function from the given input column
    to the given output column?  The answer is computed by treating the two
    columns in question as Series, and simply calling
    `series_is_a_function(other)`; see its documentation for details.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.is_a_function(input_col,output_col)` or as
    `df.can_lookup(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.is_a_function( output )

pd.DataFrame.is_a_function = dataframe_is_a_function
pd.DataFrame.can_lookup = dataframe_is_a_function

def dataframe_to_function ( self, input, output ):
    &#34;&#34;&#34;
    If the given DataFrame represents a function from the given input column
    to the given output column, which you can test using
    `dataframe_is_a_function`, then this function will construct for you a
    Python function embodying that relationship, that you can subsequently
    call.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.to_function(input_col,output_col)` or
    `df.get_function(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.to_function( output )

pd.DataFrame.to_function = dataframe_to_function

def dataframe_to_dictionary ( self, input, output ):
    &#34;&#34;&#34;
    If the given DataFrame represents a function from the given input column
    to the given output column, which you can test using
    `dataframe_is_a_function`, then this function will construct for you a
    Python dictionary embodying that relationship, that you can subsequently
    use for lookups.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.to_dictionary(input_col,output_col)`,
        `df.get_dictionary(input_col,output_col)`,
        `df.to_dict(input_col,output_col)`, or
        `df.get_dict(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.to_dictionary( output )

pd.DataFrame.to_dictionary = dataframe_to_dictionary
pd.DataFrame.get_dictionary = dataframe_to_dictionary
pd.DataFrame.to_dict = dataframe_to_dictionary
pd.DataFrame.get_dict = dataframe_to_dictionary

def dataframe_to_relation ( self, *column_names ):
    &#34;&#34;&#34;
    Given one or more column names, convert them into a relation, also called
    a predicate.  For instance, if the DataFrame is about restaurants in
    Philadelphia, we might use just the &#34;address&#34; and &#34;type&#34; columns,
    producing a relation that might be described in English as &#34;There is a
    restaurant of type Y at address X in Philadelphia.&#34;  The relation or
    predicate produced is simply a membership test into the list of tuples
    given by the columns provided.

    If `df = pd.DataFrame({&#34;A&#34;:[1,2,3],&#34;B&#34;:[4,5,6]})` and
    `R = dataframe_to_relation(df,&#34;A&#34;,&#34;B&#34;)`, then we would have
    `R(1,4) == True` but `R(1,2) == False`, becauase `R` represents the
    collection of tuples (1,4), (2,5), and (3,6).

        This function is added to the `DataFrame` class, so you can call it using
    any of the following means: `my_df.to_relation(columns...)`,
    `my_df.to_predicate(columns...)` `my_df.get_relation(columns...)`, and
    `my_df.get_predicate(columns...)`.

    If you call this function on a DataFrame but do not specify the column
    names, it assumes that all columns in the DataFrame should be used.
    &#34;&#34;&#34;
    if len( column_names ) == 0:
        column_names = self.columns
    columns = [ self[column_name] for column_name in column_names ]
    return columns[0].to_relation( *columns[1:] )

pd.DataFrame.to_relation = dataframe_to_relation
pd.DataFrame.to_predicate = dataframe_to_relation
pd.DataFrame.get_relation = dataframe_to_relation
pd.DataFrame.get_predicate = dataframe_to_relation

def dataframe_rows_satisfying ( self, test, efficient=False ):
    &#34;&#34;&#34;
    There are two ways to use this function.
    
    First, you can call `dataframe_rows_satisfying(df,S)` where `S` is a
    pandas Series of boolean values, and it will give the same result as
    `df[S]` would.  Obviously that notation is more concise, while this one is
    more explicit.
    
    Because this function will be installed in the DataFrame class, you can
    call it as `df.rows_satisfying(S)` or any of the following synonyms:
    `df.rows_where(S)`, `df.rows_such_that(S)`, `df.rows_in_which(S)`,
    `df.select(S)`, `df.select_rows(S)`, or `df.subset(S)`.

    Second, you can call `dataframe_rows_satisfying(df,P)` where `P` is any
    Python function to be used as a predicate on rows.  `P` will be called
    once for each row, with the row passed as a pandas Series.  The result of
    the function will be another DataFrame containing only the rows for which
    `P` returns True.  The same calling synonyms as above apply in this case
    as well.

    One further difference between this function and `df[S]` is that `df[S]`
    creates a slice of `df`, leading to the potential of the dreaded &#34;writing
    to a slice of a DataFrame&#34; error.  This function, by default, creates a
    copy, because this is often perfectly acceptable, given that most use
    cases do not involve big data.  You can pass the optional keyword
    argument `efficient=True` to get a slice instead of a copy.
    &#34;&#34;&#34;
    if callable( test ):
        test = pd.Series( test( row ) for _,row in self.iterrows() )
    slice = self[test]
    return slice if efficient else slice.copy()

pd.DataFrame.rows_satisfying = dataframe_rows_satisfying
pd.DataFrame.rows_such_that = dataframe_rows_satisfying
pd.DataFrame.rows_in_which = dataframe_rows_satisfying
pd.DataFrame.rows_where = dataframe_rows_satisfying
pd.DataFrame.rows_select_rows = dataframe_rows_satisfying
pd.DataFrame.rows_select = dataframe_rows_satisfying
pd.DataFrame.rows_subset = dataframe_rows_satisfying</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="clear_data.dataframe_extensions.dataframe_is_a_function"><code class="name flex">
<span>def <span class="ident">dataframe_is_a_function</span></span>(<span>self, input, output)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the given DataFrame represent a function from the given input column
to the given output column?
The answer is computed by treating the two
columns in question as Series, and simply calling
<code>series_is_a_function(other)</code>; see its documentation for details.</p>
<p>For the <code>input</code> and <code>output</code> parameters, you can pass column names, which
will be used to choose the relevant columns.
Or you can pass the columns
themselves, or any other series of the same length.
Or you can pass the
DataFrame's index, which will be converted to a Series for you.</p>
<pre><code>This function is added to the &lt;code&gt;DataFrame&lt;/code&gt; class, so you can call it as
&lt;code&gt;df.is\_a\_function(input\_col,output\_col)&lt;/code&gt; or as
</code></pre>
<p><code>df.can_lookup(input_col,output_col)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataframe_is_a_function ( self, input, output ):
    &#34;&#34;&#34;
    Does the given DataFrame represent a function from the given input column
    to the given output column?  The answer is computed by treating the two
    columns in question as Series, and simply calling
    `series_is_a_function(other)`; see its documentation for details.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.is_a_function(input_col,output_col)` or as
    `df.can_lookup(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.is_a_function( output )</code></pre>
</details>
</dd>
<dt id="clear_data.dataframe_extensions.dataframe_rows_satisfying"><code class="name flex">
<span>def <span class="ident">dataframe_rows_satisfying</span></span>(<span>self, test, efficient=False)</span>
</code></dt>
<dd>
<div class="desc"><p>There are two ways to use this function.</p>
<p>First, you can call <code><a title="clear_data.dataframe_extensions.dataframe_rows_satisfying" href="#clear_data.dataframe_extensions.dataframe_rows_satisfying">dataframe_rows_satisfying()</a>(df,S)</code> where <code>S</code> is a
pandas Series of boolean values, and it will give the same result as
<code>df[S]</code> would.
Obviously that notation is more concise, while this one is
more explicit.</p>
<p>Because this function will be installed in the DataFrame class, you can
call it as <code>df.rows_satisfying(S)</code> or any of the following synonyms:
<code>df.rows_where(S)</code>, <code>df.rows_such_that(S)</code>, <code>df.rows_in_which(S)</code>,
<code>df.select(S)</code>, <code>df.select_rows(S)</code>, or <code>df.subset(S)</code>.</p>
<p>Second, you can call <code><a title="clear_data.dataframe_extensions.dataframe_rows_satisfying" href="#clear_data.dataframe_extensions.dataframe_rows_satisfying">dataframe_rows_satisfying()</a>(df,P)</code> where <code>P</code> is any
Python function to be used as a predicate on rows.
<code>P</code> will be called
once for each row, with the row passed as a pandas Series.
The result of
the function will be another DataFrame containing only the rows for which
<code>P</code> returns True.
The same calling synonyms as above apply in this case
as well.</p>
<p>One further difference between this function and <code>df[S]</code> is that <code>df[S]</code>
creates a slice of <code>df</code>, leading to the potential of the dreaded "writing
to a slice of a DataFrame" error.
This function, by default, creates a
copy, because this is often perfectly acceptable, given that most use
cases do not involve big data.
You can pass the optional keyword
argument <code>efficient=True</code> to get a slice instead of a copy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataframe_rows_satisfying ( self, test, efficient=False ):
    &#34;&#34;&#34;
    There are two ways to use this function.
    
    First, you can call `dataframe_rows_satisfying(df,S)` where `S` is a
    pandas Series of boolean values, and it will give the same result as
    `df[S]` would.  Obviously that notation is more concise, while this one is
    more explicit.
    
    Because this function will be installed in the DataFrame class, you can
    call it as `df.rows_satisfying(S)` or any of the following synonyms:
    `df.rows_where(S)`, `df.rows_such_that(S)`, `df.rows_in_which(S)`,
    `df.select(S)`, `df.select_rows(S)`, or `df.subset(S)`.

    Second, you can call `dataframe_rows_satisfying(df,P)` where `P` is any
    Python function to be used as a predicate on rows.  `P` will be called
    once for each row, with the row passed as a pandas Series.  The result of
    the function will be another DataFrame containing only the rows for which
    `P` returns True.  The same calling synonyms as above apply in this case
    as well.

    One further difference between this function and `df[S]` is that `df[S]`
    creates a slice of `df`, leading to the potential of the dreaded &#34;writing
    to a slice of a DataFrame&#34; error.  This function, by default, creates a
    copy, because this is often perfectly acceptable, given that most use
    cases do not involve big data.  You can pass the optional keyword
    argument `efficient=True` to get a slice instead of a copy.
    &#34;&#34;&#34;
    if callable( test ):
        test = pd.Series( test( row ) for _,row in self.iterrows() )
    slice = self[test]
    return slice if efficient else slice.copy()</code></pre>
</details>
</dd>
<dt id="clear_data.dataframe_extensions.dataframe_to_dictionary"><code class="name flex">
<span>def <span class="ident">dataframe_to_dictionary</span></span>(<span>self, input, output)</span>
</code></dt>
<dd>
<div class="desc"><p>If the given DataFrame represents a function from the given input column
to the given output column, which you can test using
<code><a title="clear_data.dataframe_extensions.dataframe_is_a_function" href="#clear_data.dataframe_extensions.dataframe_is_a_function">dataframe_is_a_function()</a></code>, then this function will construct for you a
Python dictionary embodying that relationship, that you can subsequently
use for lookups.</p>
<p>For the <code>input</code> and <code>output</code> parameters, you can pass column names, which
will be used to choose the relevant columns.
Or you can pass the columns
themselves, or any other series of the same length.
Or you can pass the
DataFrame's index, which will be converted to a Series for you.</p>
<pre><code>This function is added to the &lt;code&gt;DataFrame&lt;/code&gt; class, so you can call it as
&lt;code&gt;df.to\_dictionary(input\_col,output\_col)&lt;/code&gt;,
&lt;code&gt;df.get\_dictionary(input\_col,output\_col)&lt;/code&gt;,
&lt;code&gt;df.to\_dict(input\_col,output\_col)&lt;/code&gt;, or
&lt;code&gt;df.get\_dict(input\_col,output\_col)&lt;/code&gt;.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataframe_to_dictionary ( self, input, output ):
    &#34;&#34;&#34;
    If the given DataFrame represents a function from the given input column
    to the given output column, which you can test using
    `dataframe_is_a_function`, then this function will construct for you a
    Python dictionary embodying that relationship, that you can subsequently
    use for lookups.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.to_dictionary(input_col,output_col)`,
        `df.get_dictionary(input_col,output_col)`,
        `df.to_dict(input_col,output_col)`, or
        `df.get_dict(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.to_dictionary( output )</code></pre>
</details>
</dd>
<dt id="clear_data.dataframe_extensions.dataframe_to_function"><code class="name flex">
<span>def <span class="ident">dataframe_to_function</span></span>(<span>self, input, output)</span>
</code></dt>
<dd>
<div class="desc"><p>If the given DataFrame represents a function from the given input column
to the given output column, which you can test using
<code><a title="clear_data.dataframe_extensions.dataframe_is_a_function" href="#clear_data.dataframe_extensions.dataframe_is_a_function">dataframe_is_a_function()</a></code>, then this function will construct for you a
Python function embodying that relationship, that you can subsequently
call.</p>
<p>For the <code>input</code> and <code>output</code> parameters, you can pass column names, which
will be used to choose the relevant columns.
Or you can pass the columns
themselves, or any other series of the same length.
Or you can pass the
DataFrame's index, which will be converted to a Series for you.</p>
<pre><code>This function is added to the &lt;code&gt;DataFrame&lt;/code&gt; class, so you can call it as
&lt;code&gt;df.to\_function(input\_col,output\_col)&lt;/code&gt; or
</code></pre>
<p><code>df.get_function(input_col,output_col)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataframe_to_function ( self, input, output ):
    &#34;&#34;&#34;
    If the given DataFrame represents a function from the given input column
    to the given output column, which you can test using
    `dataframe_is_a_function`, then this function will construct for you a
    Python function embodying that relationship, that you can subsequently
    call.

    For the `input` and `output` parameters, you can pass column names, which
    will be used to choose the relevant columns.  Or you can pass the columns
    themselves, or any other series of the same length.  Or you can pass the
    DataFrame&#39;s index, which will be converted to a Series for you.

        This function is added to the `DataFrame` class, so you can call it as
        `df.to_function(input_col,output_col)` or
    `df.get_function(input_col,output_col)`.
    &#34;&#34;&#34;
    # ensure input is a Series
    if type( input ) is str:
        input = self[input]
    elif isinstance( input, pd.Index ):
        input = input.to_series()
    # ensure output is a Series
    if type( output ) is str:
        output = self[output]
    elif isinstance( output, pd.Index ):
        output = output.to_series()
    # do the work
    return input.to_function( output )</code></pre>
</details>
</dd>
<dt id="clear_data.dataframe_extensions.dataframe_to_relation"><code class="name flex">
<span>def <span class="ident">dataframe_to_relation</span></span>(<span>self, *column_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Given one or more column names, convert them into a relation, also called
a predicate.
For instance, if the DataFrame is about restaurants in
Philadelphia, we might use just the "address" and "type" columns,
producing a relation that might be described in English as "There is a
restaurant of type Y at address X in Philadelphia."
The relation or
predicate produced is simply a membership test into the list of tuples
given by the columns provided.</p>
<p>If <code>df = pd.DataFrame({"A":[1,2,3],"B":[4,5,6]})</code> and
<code>R = dataframe_to_relation(df,"A","B")</code>, then we would have
<code>R(1,4) == True</code> but <code>R(1,2) == False</code>, becauase <code>R</code> represents the
collection of tuples (1,4), (2,5), and (3,6).</p>
<pre><code>This function is added to the &lt;code&gt;DataFrame&lt;/code&gt; class, so you can call it using
</code></pre>
<p>any of the following means: <code>my_df.to_relation(columns&hellip;)</code>,
<code>my_df.to_predicate(columns&hellip;)</code> <code>my_df.get_relation(columns&hellip;)</code>, and
<code>my_df.get_predicate(columns&hellip;)</code>.</p>
<p>If you call this function on a DataFrame but do not specify the column
names, it assumes that all columns in the DataFrame should be used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataframe_to_relation ( self, *column_names ):
    &#34;&#34;&#34;
    Given one or more column names, convert them into a relation, also called
    a predicate.  For instance, if the DataFrame is about restaurants in
    Philadelphia, we might use just the &#34;address&#34; and &#34;type&#34; columns,
    producing a relation that might be described in English as &#34;There is a
    restaurant of type Y at address X in Philadelphia.&#34;  The relation or
    predicate produced is simply a membership test into the list of tuples
    given by the columns provided.

    If `df = pd.DataFrame({&#34;A&#34;:[1,2,3],&#34;B&#34;:[4,5,6]})` and
    `R = dataframe_to_relation(df,&#34;A&#34;,&#34;B&#34;)`, then we would have
    `R(1,4) == True` but `R(1,2) == False`, becauase `R` represents the
    collection of tuples (1,4), (2,5), and (3,6).

        This function is added to the `DataFrame` class, so you can call it using
    any of the following means: `my_df.to_relation(columns...)`,
    `my_df.to_predicate(columns...)` `my_df.get_relation(columns...)`, and
    `my_df.get_predicate(columns...)`.

    If you call this function on a DataFrame but do not specify the column
    names, it assumes that all columns in the DataFrame should be used.
    &#34;&#34;&#34;
    if len( column_names ) == 0:
        column_names = self.columns
    columns = [ self[column_name] for column_name in column_names ]
    return columns[0].to_relation( *columns[1:] )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clear_data" href="index.html">clear_data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="clear_data.dataframe_extensions.dataframe_is_a_function" href="#clear_data.dataframe_extensions.dataframe_is_a_function">dataframe_is_a_function</a></code></li>
<li><code><a title="clear_data.dataframe_extensions.dataframe_rows_satisfying" href="#clear_data.dataframe_extensions.dataframe_rows_satisfying">dataframe_rows_satisfying</a></code></li>
<li><code><a title="clear_data.dataframe_extensions.dataframe_to_dictionary" href="#clear_data.dataframe_extensions.dataframe_to_dictionary">dataframe_to_dictionary</a></code></li>
<li><code><a title="clear_data.dataframe_extensions.dataframe_to_function" href="#clear_data.dataframe_extensions.dataframe_to_function">dataframe_to_function</a></code></li>
<li><code><a title="clear_data.dataframe_extensions.dataframe_to_relation" href="#clear_data.dataframe_extensions.dataframe_to_relation">dataframe_to_relation</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>